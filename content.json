[{"title":"设计模式之工厂模式","date":"2017-05-03T16:00:00.000Z","path":"设计模式/设计模式之工厂模式/","text":"除了使用new操作符之外，还有更多制造对象的方法。你将了解到实例化这个活动不应该总是公开地进行，也会认识到初始化经常造成“耦合”问题。你不希望这样，对吧？读下去，你将了解工厂模式如何从复杂的依赖中帮你脱困。 当看到“new”，就会想到“具体”我们不应该针对实现编程，但是当我们使用“new”时，不正是在针对实现编程吗？是的，当使用“new”时，的确是在实例化一个具体类，所以用的确实是实现，而不是接口。 这是一个好问题，代码绑着具体类会导致代码更脆弱，更缺乏弹性。 12345678Duck duck;if(picnic)&#123; duck = new MallardDuck(); &#125;else if(hunting)&#123; duck = new DecoyDuck();&#125;...... 这里有一些要实例化的具体类，究竟实例化哪个类，要在运行时由一些条件决定。 当看到这样的代码，一旦有变化或扩展，就必须重新打开这段代码进行检查和修改。通常这样修改过的代码将造成部分系统更难维护和更新，而且也更容易犯错。 “new”有什么不对劲？在技术上，“new”没有错，毕竟这是Java的基础部分。真正的犯人是“改变”，以及它是如何影响“new”的使用的。 针对接口编程，可以隔离掉以后系统可能发生的一大堆改变。为什么呢？如果代码是针对接口而写，那么通过多态，它可以与任何新类实现该接口。但是，当代码使用大量的具体类时，等于是自找麻烦，因为一旦加入新的具体类，就必须改变代码。也就是说，代码并非“对修改关闭”。想用新的具体类型类扩展代码，必须重新打开它。 所以，该怎么办呢？当遇到这样的问题时，就应该到OO设计原则中去寻找线索。其中一个原则就是：找出会变化的方面，把它们从不变的部分分离出来。 识别变化的方面假设你有一个披萨店，你的代码可能这么写： 1234567891011public Pizza orderPizza()&#123; Pizza pizza = new Pizza(); //为了让系统有弹性，我们很希望这是一个抽象类或接口。但如果这 //样，这些类或接口就无法直接实例化 //一旦我们有了一个披萨，需要做一些准备（就是擀揉面皮、加上佐料），然后烘烤、切片、装盒 pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza;&#125; 但是你需要更多披萨类型······所以必须增加一些代码，来“决定”适合的披萨类型，然后再“制造”这个披萨： 1234567891011121314151617181920//现在把披萨类型传入orderPizza()public Pizza orderPizza(String type)&#123; Pizza pizza; //根据披萨的类型，我们实例化正确的具体类，然后将其赋值给pizza实例变量。请注意，这里的任何披萨 都必须实现Pizza接口 if(type.equals(\"cheese\"))&#123; pizza = new CheesePizza(); &#125;else if(type.equals(\"greek\"))&#123; pizza = new GreekPizza(); &#125;else if(type.equals(\"pepperoni\"))&#123; pizza = new PepperoniPizza(); &#125; pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); //每个Pizza的子类型都知道如何准备、烘烤、切片、装盒 return pizza;&#125; 但是压力来自于增加更多的披萨类型你发现你所有的竞争者都已经在他们的菜单中加入了一些流行风味的披萨：Clam Pizza（蛤蜊披萨）、Veggie Pizza（素食披萨）。很明显，你必须要赶上他们，所以也要把这些风味加进你的菜单中。而最近Greek Pizza（希腊披萨）卖的不好，所以你决定将它从菜单中去掉： 123456789101112131415161718192021222324public Pizza orderPizza(String type)&#123; Pizza pizza; //此代码“没有”对修改封闭。如果披萨店改变它所供应的披萨风味，就得进到这里来修改 if(type.equals(\"cheese\"))&#123; pizza = new CheesePizza(); &#125; //移除GreekPizza &#125;else if(type.equals(\"pepperoni\"))&#123; pizza = new PepperoniPizza(); &#125;else if(type.equals(\"clam\"))&#123; //添加ClamPizza和VeggiePizza pizza = new ClamPizza(); &#125;else if(type.equals(\"veggie\"))&#123; pizza = new VeggiePizza(); &#125; //这里是我们不想改变的地方。因为披萨的准备、烘烤、切片、包装，多年来都持续不变，所以这部分代 码不会改变，只有发生这些动作的披萨会改变 pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza;&#125; 很明显地，如果实例化“某些”具体类，将使 orderPizza() 出问题，而且也无法让 orderPizza() 对修改关闭；但是，现在我们已经知道哪些会改变，哪些不会改变，该是使用封装的时候了。 封装创建对象的代码现在最好将创建对象移到 orderPizza() 之外，但怎么做呢？这个嘛，要把创建披萨的代码移到另一个对象中，由这个新对象专职创建披萨。 1234567891011121314public Pizza orderPizza(String type)&#123; Pizza pizza; //首先，把创建对象的代码从orderPizza()方法中抽离，然后把这部分的代码搬到另一个对象 （SimplePizzaFactory）中，这个新对象只管如何创建披萨。如果任何对象想要创建披萨，找它就对了 //这里该怎么写？ pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza;&#125; 我们称这个新对象为“工厂”。 工厂（factory）处理创建对象的细节。一旦有了 SimplePizzaFactory ，orderPizza() 就变成此对象的客户。当需要披萨时，就叫披萨工厂做一个。现在 orderPizza() 方法只关心从工厂得到了一个披萨，而这个披萨实现了Pizza接口，所以它可以调用 prepare() 、bake() 、cut() 、box() 来分别进行准备、烘烤、切片、装盒。 建立一个简单披萨工厂先从工厂本身开始。我们要定义一个类，为所有披萨封装创建对象的代码。代码像这样······ 123456789101112131415161718192021//SimplePizzaFactory只做一件事情：帮它的客户创建披萨public class SimplePizzaFactory&#123; //所有客户用createPizza()方法来实例化新对象 public Pizza createPizza(String type)&#123; Pizza pizza; //这是从orderPizza()方法中移过来的代码 if(type.equals(\"cheese\"))&#123; pizza = new CheesePizza(); &#125;else if(type.equals(\"pepperoni\"))&#123; pizza = new PepperoniPizza(); &#125;else if(type.equals(\"clam\"))&#123; pizza = new ClamPizza(); &#125;else if(type.equals(\"veggie\"))&#123; pizza = new VeggiePizza(); &#125; return pizza; &#125; &#125; 这么做有什么好处？似乎只是把问题搬到另一个对象罢了，问题依然存在。 别忘了，SimplePizzaFactory可以有许多的客户。虽然目前只看到 orderPizza() 方法是它的客户，然 而，可能还有PizzaShopMenu（披萨店菜单）类，会利用这个工厂来取得披萨的价钱和描述。 所以，把创建披萨的代码包装进一个类，当以后实现改变时，只需修改这个类即可。别忘了，我们也正要把具体实例化的过程，从客户的代码中删除！ 这与把工厂定义成一个静态的方法有何差别？ 利用静态方法定义一个简单的工厂，这是很常见的技巧，常被称为静态工厂，无需使用创建对象的方法即可实例化对象。但请记住，这也有缺点，不能通过继承来改变创建方法的行为。 重做PizzaStore类是时候修改我们的客户代码了，我们所要做的是仰仗工厂来为我们创建披萨，要做这样的改变： 123456789101112131415161718192021public class PizzaStore &#123; SimplePizzaFactory factory = null; public PizzaStore(SimplePizzaFactory factory) &#123; this.factory = factory; &#125; public Pizza orderPizza(String type) &#123; Pizza pizza; //请注意，我们把new操作符替换成工厂对象的创建方法，这里不再使用具体实例化，而是通过类型来 使用工厂创建披萨 pizza = factory.createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; &#125;&#125; 定义简单工厂简单工厂其实不是一个设计模式，反而比较像是一种编程习惯。有些开发人员的确是把这个编程习惯误认为是“工厂模式”（Factory Pattern）。不要因为简单工厂不是一个“真正的”模式，就忽略了它的用法。让我们来看看新的披萨店类图： 谢谢简单工厂来为我们暖身。接下来登场的是两个重量级的模式，它们都是工厂。 但是别担心，未来还有更多的披萨！ 再提醒一次：在设计模式中，所谓的 “实现一个接口” 并 “不一定” 表示 “写一个类，并利用implement关键词来实现某个Java接口”。“实现一个接口” 泛指 “实现某个超类型（可以是类或接口的某个方法）”。 工厂方法模式加盟披萨店披萨店经营有成，击败了竞争者，现在大家都希望披萨店能够在自家附近有加盟店。但是每家加盟店都可能想要提供不同风味的披萨（比方说纽约、芝加哥、加州）。 我们已经有一个做法······如果利用SimplePizzaFactory，写出三种不同的工厂，分别是NYPizzaFactory、ChicagoPizzaFactory、CaliforniaPizzaFactory，那么各地加盟店都有适合的工厂可以使用，这是一种做法。 让我们来看看会变成什么样子······ 123NYPizzaFactory nyFactory = new NYPizzaFactory();//这里创建的工厂，是制造纽约风味的披萨PizzaStore nyStore = new PizzaStore(nyFactory);//然后建立一个披萨店，将纽约工厂的引用作为参数nyStore.orderPizza(\"Veggie\");//当我们制造披萨，会得到纽约风味的披萨 123ChicagoPizzaFactory chicagoFactory = new ChicagoPizzaFactory();PizzaStore chicagoStore = new PizzaStore(chicagoFactory);chicagoStore.orderPizza(\"Veggie\");//芝加哥披萨店也类似，制造出来的披萨，是芝加哥风味的披萨 但是你想要多一些质量控制······在推广SimpleFactory时，你发现加盟店的确是采用你的工厂创建披萨，但是其他部分，却开始采用他们自创的流程：烘烤的做法有些差异、不要切片、使用其他厂商的盒子。 再想想这个问题，你真的希望能够建立一个框架，把加盟店和创建披萨捆绑在一起的同时又保持一定的弹性。 在我们稍早的SimplePizzaFactory代码之前，制作披萨的代码捆绑在PizzaStore里，但这么做却没有弹性。那么，该如何做呢？ 给披萨店使用的框架有个做法可让披萨制作活动局限于PizzaStore类，而同时又能让这些加盟店依然可以自由地制作该区域的风味。 所要做的事情，就是把 createPizza() 这个“工厂方法”放回到PizzaStore中，不过要把它设置成“抽象方法”，然后为每个区域风味创建一个PizzaStore的子类。 首先，看看PizzaStore所做的改变： 12345678910111213141516171819public abstract class PizzaStore&#123; public Pizza orderPizza(String type)&#123; Pizza pizza; //现在createPizza()方法从工厂对象中移回PizzaStore pizza = createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; &#125; //现在把工厂对象移到这个方法中 protected abstract Pizza createPizza(String type); &#125; 现在已经有一个PizzaStore作为超类；让每个域类型（NYPizzaStore、ChicagoPizzaStore、CaliforniaPizzaStore）都继承这个PizzaStore，每个子类各自决定如何制造披萨。让我们看看这要如何进行。 允许子类做决定别忘了，PizzaStore已经有一个不错的订单系统，由 orderPizza() 方法负责处理订单，而你希望所有加盟店对于订单的处理都能够一致。 各个区域披萨店之间的差异在于他们制作披萨的风味，我们现在要让 createPizza() 能够应对这些变化来负责创建正确种类的披萨。做法是让PizzaStore的各个子类负责定义自己的 createPizza() 方法。所以我们会得到一些PizzaStore具体的子类，每个子类都有自己的披萨变体，而仍然适合PizzaStore框架，并使用调试好的 orderPizza() 方法。 orderPizza() 方法在抽象的PizzaStore内而不是在子类中定义。所以此方法并不知道哪个子类将实际上制作披萨。 现在，更进一步地，orderPizza() 方法对Pizza对象做了许多事情（例如：准备、烘烤、切片、装盒），但由于Pizza对象是抽象的，orderPizza() 并不知道哪些实际的具体类参与进来了。换句话说，这就是解耦！ orderPizza() 调用 createPizza() 取得披萨对象。但究竟会取得哪一种披萨？这不是 orderPizza() 方法所能决定的，那么究竟是由谁来做决定呢？ 当 orderPizza() 调用 createPizza() 时，某个披萨店子类将负责创建披萨。做哪一种披萨呢？当然是由具体的披萨店来决定（例如：NYStylePizzaStore、ChicagoStylePizzaStore）。 让我们开一家披萨店吧！开加盟店有它的好处，可以从PizzaStore免费取得所有的功能。区域店只需要继承PizzaStore，然后提供 createPizza() 方法实现自己的披萨风味即可。这里将以纽约风味的加盟店为例，其余风味的加盟店类似： 123456789101112131415public class NYStylePizzaStore extends PizzaStore &#123; @Override protected Pizza createPizza(String type) &#123; //这就是创建具体类的地方。对于每一种披萨类型，都是创建纽约风味。 if (type.equals(\"cheese\")) &#123; return new NYStyleCheesePizza(); &#125; else if (type.equals(\"veggie\")) &#123; return new NYStyleVeggiePizza(); &#125; else return null; &#125; //请注意，超类的orderPizza()方法，并不知道正在创建的披萨是哪一种，它只知道这个披萨可以 //被准备、烘烤、切片、装盒！&#125; 声明一个工厂方法原本是由一个对象负责所有具体类的实例化，现在通过对PizzaStore做一些小转变，变成由一群子类来负责实例化。让我们看得更仔细些： 12345678910111213141516171819public abstract class PizzaStore&#123; public Pizza orderPizza(String type)&#123; Pizza pizza; pizza = createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; &#125; //PizzaStore的子类在createPizza()方法中处理对象的实例化； //现在，实例化披萨的责任被移到一个“方法”中，此方法就如同是一个“工厂”。 protected abstract Pizza createPizza(String type); &#125; 工厂方法用来处理对象的创建，并将这样的行为封装在子类中。这样，客户程序中关于超类的代码就和子类对象创建代码解耦了。 1234//1.工厂方法是抽象的，所以依赖子类来处理对象的创建//2.工厂方法必须返回一个产品。超类中定义的方法，通常使用到工厂方法的返回值//3.工厂方法将客户（也就是超类中的代码，例如orderPizza()）和实际创建具体产品的代码分隔开来abstract Product factoryMethod(String type) 看看如何根据订单生产这些披萨······ 首先我们需要一个披萨店（例如：纽约披萨店）： 1PizzaStore nyStylePizzaStore = new NYStylePizzaStore(); 现在有了一个店，可以下订单了： 1nyStylePizzaStore.orderPizza(\"cheese\"); orderPizza()方法于是调用createPizza()方法： 12//别忘了，工厂方法createPizza()是在子类中实现的。在这个例子中，它会返回纽约芝士披萨。Pizza pizza = createPizza(\"cheese\"); 最后，披萨必须经过下列的处理才算完成orderPizza()： 1234pizza.prepare();pizza.bake();pizza.cut();pizza.box(); 忽略了一件事：披萨本身！如果没有披萨可出售，我们的披萨店开得再多也不行。现在让我们来实现披萨： 1234567891011121314151617181920212223242526272829303132333435public abstract class Pizza &#123; //每一个披萨都具有名称、面团类型、酱料类型、一套佐料 String name; String dough; String sauce; ArrayList toppings = new ArrayList(); //此抽象类提供了某些默认的基本做法，用来进行烘烤、切片、装盒 public void prepare() &#123; System.out.println(\"Preparing \" + name); System.out.println(\"Tossing dough... \"); System.out.println(\"Adding sauce... \"); System.out.println(\"Adding toppings: \"); for (int i = 0; i &lt; toppings.size(); i++) &#123; System.out.println(\" \" + toppings.get(i)); &#125; &#125; public void bake() &#123; System.out.println(\"Bake for 25 minutes at 350\"); &#125; public void cut() &#123; System.out.println(\"Cutting the pizza into diagonal slices\"); &#125; public void box() &#123; System.out.println(\"Place pizza in official PizzaStore box\"); &#125; public String getName() &#123; return name; &#125;&#125; 现在我们需要一些具体子类······来定义纽约和芝加哥风味的芝士披萨，怎么样？ 1234567891011//纽约芝士披萨public class NYStyleCheesePizza extends Pizza &#123; public NYStyleCheesePizza() &#123; name = \"NY Style Sauce and Cheese Pizza\"; dough = \"Thin Crust Dough\"; sauce = \"Marinara Sauce\"; toppings.add(\"Grated Reggiano Cheese\"); &#125;&#125; 123456789101112131415//芝加哥芝士披萨public class ChicagoStyleCheesePizza extends Pizza &#123; public ChicagoStyleCheesePizza() &#123; name = \"Chicago Style Deep Dish Cheese Pizza\"; dough = \"Extra Thick Crust Dough\"; sauce = \"Plum Tomato Sauce\"; toppings.add(\"Shredded Mozzarella Cheese\"); &#125; public void cut() &#123; System.out.println(\"Cutting the pizza into square slices\"); &#125;&#125; 你已经等得够久了，来吃些披萨吧！123456789101112131415161718public class PizzaTestDrive &#123; public static void main(String[] args) &#123; //首先建立两个不同的店 PizzaStore nyStore = new NYStylePizzaStore(); PizzaStore chicagoStore = new ChicagoStylePizzaStore(); Pizza pizza = nyStore.orderPizza(\"cheese\"); System.out.println(pizza.getName()); System.out.println(\"\\n\"); pizza = chicagoStore.orderPizza(\"cheese\"); System.out.println(pizza.getName()); &#125;&#125; 代码运行结果如下： 1234567891011121314151617181920Preparing NY Style Sauce and Cheese PizzaTossing dough... Adding sauce... Adding toppings: Grated Reggiano CheeseBake for 25 minutes at 350Cutting the pizza into diagonal slicesPlace pizza in official PizzaStore boxNY Style Sauce and Cheese PizzaPreparing Chicago Style Deep Dish Cheese PizzaTossing dough... Adding sauce... Adding toppings: Shredded Mozzarella CheeseBake for 25 minutes at 350Cutting the pizza into square slicesPlace pizza in official PizzaStore boxChicago Style Deep Dish Cheese Pizza 认识工厂方法模式的时刻终于到了所有工厂模式都用来封装对象的创建。工厂方法模式通过让子类决定该创建的对象是什么，来达到将对象的创建的过程封装的目的。让我们来看看这些类图，以了解有哪些组成元素： 另一个观点：平行的类层级我们已经看到，将一个 orderPizza() 方法和一个工厂方法联合起来，就可以成为一个框架。除此之外，工厂方法将生产知识封装进各个创建者，这样的做法，也可以被视为是一个框架。 让我们来看看这两个平行的类层级，并认清它们的关系： 定义工厂方法模式下面是工厂方法模式的正式定义： ​ 工厂方法模式定义了一个创建对象的接口（也称为“工厂方法”），但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。 一个很依赖的披萨店假设你从未听说过OO工厂。下面是一个不适用工厂模式的披萨店版本： 1234567891011121314151617181920212223242526272829303132333435public class DependentPizzaStore &#123; public Pizza createPizza(String style, String type) &#123; Pizza pizza = null; if (style.equals(\"NY\")) &#123; if (type.equals(\"cheese\")) &#123; return new NYStyleCheesePizza(); &#125; else if (type.equals(\"veggie\")) &#123; return new NYStyleVeggiePizza(); &#125; else if (type.equals(\"clam\")) &#123; return new NYStyleClamPizza(); &#125; else if (type.equals(\"pepperoni\")) &#123; return new NYStylePepperoniPizza(); &#125; &#125; else if (style.equals(\"Chicago\")) &#123; if (type.equals(\"cheese\")) &#123; return new ChicagoStyleCheesePizza(); &#125; else if (type.equals(\"veggie\")) &#123; return new ChicagoStyleVeggiePizza(); &#125; else if (type.equals(\"clam\")) &#123; return new ChicagoStyleClamPizza(); &#125; else if (type.equals(\"pepperoni\")) &#123; return new ChicagoStylePepperoniPizza(); &#125; &#125; else &#123; System.out.println(\"Error:invalid type of pizza\"); return null; &#125; pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; &#125;&#125; 当你直接实例化一个对象时，就是在依赖它的具体类。看看这个依赖性很高的披萨店例子，它由披萨店类来创建所有的披萨对象，而不是委托给工厂。 这个版本的 PizzaStore 依赖于所有的披萨对象，因为它直接创建这些披萨对象。因为对于披萨具体实现的任何改变都会影响到 PizzaStore ，我们说 PizzaStore “依赖于“ 披萨的实现。每新增一个披萨种类，就等于让 PizzaStore 多了一个依赖。 依赖倒置原则很清楚地，代码里减少对于具体类的依赖是件“好事”。事实上，有一个OO设计原则就正式阐明了这一点；这个原则甚至还有一个又响亮又正式的名称：“依赖倒置原则”。 通则如下：要依赖抽象，不要依赖具体类。 首先，这个原则听起来很像是“针对接口编程，不针对实现编程”，不是吗？的确很相似，然而这里更强调“抽象”。这个原则说明了：不能让高层组件依赖低层组件，而且，不管高层或低层组件，“两者”都应该依赖于抽象。所谓“高层”组件，是由其他低层组件定义其行为的类。例如，PizzaStore是个高层组件，因为它的行为是由披萨定义的：PizzaStore创建所有不同的披萨对象、准备、烘烤、切片、装盒；而披萨本身属于低层组件。 我们来想想看怎样在“一个很依赖的披萨店”实现中，应用这个原则······ 原则的应用“一个很依赖的披萨店”的主要问题在于：它依赖每个披萨类型。因为它是在自己的 orderPizza() 方法中，实例化这些具体类型的。 虽然我们已经创建了一个抽象，也就是Pizza，但我们仍然在代码中，实际地创建了具体的Pizza，所以，这个抽象没什么影响力。 如何在 orderPizza() 方法中，将这些实例化对象的代码独立出来？我们都知道，工厂方法刚好能派上用场。 所以，应用工厂方法之后，类图看起来就像这样： 在应用工厂方法之后，你就注意到，高层组件（也就是PizzaStore）和低层组件（也就是这些具体的披萨）都依赖了Pizza抽象。想要遵循依赖倒置原则，工厂方法并非是唯一的技巧，但却是最有威力的技巧之一。 依赖倒置原则，究竟倒置在哪里？在依赖倒置原则中的倒置指的是和一般OO设计的思考方式完全相反。看看前一张图，你会注意到低层组件现在竟然依赖高层的抽象。同样地，高层组件现在也依赖相同的抽象。前几张绘制的依赖图是由上而下的，现在却倒置了，而且高层与低层模块现在都依赖这个抽象。 让我们好好地回顾一个设计过程来看看，究竟使用了这个原则之后，对设计的思考方式会被怎样地倒置····· 如果你需要实现一个披萨店，你第一件想到的事情是什么？ 嗯！披萨店进行准备、烘烤、装盒，所以我的店必须能制作许多不同风味的披萨，例如：芝士披萨、素食披萨、蛤蜊披萨······ 没错！先从顶端开始，然后往下到具体类。但是，正如你所看到的你不想让披萨店理会这些具体类，要不然披萨店将全部依赖这些具体类。现在，“倒置”你的想法······别从顶端开始，而是从披萨（Pizza）开始，然后想想看能抽象化些什么。 是的，芝士披萨、素食披萨和蛤蜊披萨都是披萨，所以它们应该共享一个Pizza接口。 对了，你想要抽象化一个Pizza。好，现在回头重新思考如何设计披萨店。 既然我已经有一个披萨抽象，就可以开始设计披萨店，而不用理会具体的披萨类了。 很接近了，但是要这么做，必须靠一个工厂来将这些具体类取出披萨店。一旦你这么做了，各种不同的具体披萨类型就只能依赖一个抽象，而披萨店也会依赖这个抽象。我们已经倒置了一个商店依赖具体类的设计，而且也倒置了你的思考方式。 几个指导方针帮助你遵循此原则······下面的指导方针，能帮你避免在OO设计中违反依赖倒置原则： 变量不可以持有具体类的引用（如果使用new，就会持有具体类的引用。你可以改用工厂方法来避开这样的做法。） 不要让类派生自具体类。（如果派生自具体类，你就会依赖具体类。请派生自一个抽象（接口或抽象类）） 不要覆盖基类中已实现的方法。（如果覆盖基类中已实现的方法，那么你的基类就不是一个真正适合被继承的抽象。基类中已实现的方法，应该由所有的子类共享。）","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.huangheng.site/categories/设计模式/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.huangheng.site/tags/java/"},{"name":"pattern","slug":"pattern","permalink":"http://www.huangheng.site/tags/pattern/"}]},{"title":"用两个队列实现栈","date":"2017-05-02T16:00:00.000Z","path":"编程题/用两个队列实现栈/","text":"用两个队列实现栈。栈的声明如下，请实现它的两个函数push和pop，分别完成结点入栈和出栈的功能。 我们通过一系列栈的压入和弹出操作来分析用两个队列模拟一个栈的过程。我们先往栈内压入一个元素a。由于两个队列现在都是空的，我们可以选择把a插入到两个队列中的任意一个。我们不妨把a插入queue1。接下来继续往栈内压入b、c两个元素，我们把它们都插入queue1。这个时候queue1包含3个元素a、b和c，其中a位于队列的头部，c位于队列的尾部（如图1（a）所示）。 现在我们考虑从栈内弹出一个元素。根据栈的后入先出原则，最后被压入栈的c应该最先被弹出。由于c位于queue1的尾部，而我们每次只能从队列的头部删除元素，因此我们可以先从queue1中依次删除元素a、b并插入到queue2中，再从queue1中删除元素c。这就相当于从栈中弹出元素c了（如图1（b）所示）。我们可以用同样的方法从栈内弹出元素b（如图1（c）所示）。 接下来我们考虑往栈内压入一个元素d。此时queue1已经有一个元素，我们就把d插入到queue1的尾部（如图1（d）所示）。如果我们再从栈内弹出一个元素，此时被弹出的应该是最后被压入栈的d。由于d位于queue1的尾部，我们只能先从头删除queue1的元素并插入到queue2，直到在queue1中遇到d再直接把它删除（如图1（e）所示）。 参考代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class StackUsingTwoQueue&lt;T&gt; &#123; //声明两个队列:queue1、queue2 private LinkedBlockingQueue&lt;T&gt; queue1; private LinkedBlockingQueue&lt;T&gt; queue2; public StackUsingTwoQueue() &#123; queue1 = new LinkedBlockingQueue&lt;T&gt;(); queue2 = new LinkedBlockingQueue&lt;T&gt;(); &#125; /** * 将一个元素入栈 * * @param element 将要入栈的元素 */ public void push(T element) &#123; try &#123; //将元素插入到不为空的队列的尾部，如果两个队列均为空则插入到queue1 if (queue1.size() &lt;= 0 &amp;&amp; queue2.size() &lt;= 0) &#123; queue1.put(element); &#125; else if (queue1.size() &gt; 0) &#123; queue1.put(element); &#125; else &#123; queue2.put(element); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; /** * 将栈顶元素出栈 * * @return 栈顶元素 */ public T pop() &#123; T result = null; if (queue1.size() &lt;= 0 &amp;&amp; queue2.size() &lt;= 0) &#123; //栈为空 System.out.print(\"Stack is empty.\"); return null; &#125; else if (queue1.size() &gt; 0 &amp;&amp; queue2.size() &lt;= 0) &#123; //队列queue1不为空，queue2为空， //将queue1中除尾部元素之外的全部元素依次出队列并插入到queue2队列中 try &#123; while (queue1.size() &gt; 1) &#123; T element = queue1.poll(); queue2.put(element); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //queue1中仅剩的一个元素即为栈顶元素 result = queue1.poll(); &#125; else if (queue1.size() &lt;= 0 &amp;&amp; queue2.size() &gt; 0) &#123; //队列queue2不为空，queue1为空， //将queue2中除尾部元素之外的全部元素依次出队列并插入到queue1队列中 try &#123; while (queue2.size() &gt; 1) &#123; T element = queue2.poll(); queue1.put(element); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //queue2中仅剩的一个元素即为栈顶元素 result = queue2.poll(); &#125; return result; &#125;&#125;","categories":[{"name":"编程题","slug":"编程题","permalink":"http://www.huangheng.site/categories/编程题/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.huangheng.site/tags/java/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.huangheng.site/tags/algorithm/"}]},{"title":"用两个栈实现队列","date":"2017-05-01T16:00:00.000Z","path":"编程题/用两个栈实现队列/","text":"用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail和deleteHead，分别完成在队列尾部插入结点和在队列头部删除结点的功能。 我们通过一个具体的例子来分析往该队列插入和删除元素的过程。首先插入一个元素a，不妨先把它插入到stack1，此时stack1中的元素有{a}，stack2为空。再插入两个元素b和c，还是插入到stack1中，此时stack1中的元素有{a,b,c}，其中c位于栈顶，而stack2仍然是空的（如图1（a）所示）。 这个时候我们试着从队列中删除一个元素。按照队列先入先出的规则，由于a比b、c先插入到队列中，最先被删除的元素应该是a。元素a存储在stack1中，但并不在栈顶上，因此不能直接进行删除。注意到stack2我们还一直没有使用过，现在是让stack2发挥作用的时候了。如果我们把stack1中的元素逐个弹出并压入stack2，元素在stack2中的顺序正好和原来在stack1中的顺序相反。因此经过3次弹出stack1和压入stack2操作之后，stack1为空，而stack2中的元素是{c,b,a}，这个时候就可以弹出stack2的栈顶a了。此时的stack1为空，而stack2的元素为{c,b}，其中b在栈顶（如图1（b）所示）。 如果我们还想继续删除队列的头部应该怎么办呢？剩下的两个元素是b和c，b比c早进入队列，因此b应该先删除。而此时b恰好又在栈顶上，因此直接弹出stack2的栈顶即可。这次弹出操作之后，stack1中仍然为空，而stack2为{c}（如图1（c）所示）。 从上面的分析中我们可以总结出删除一个元素的步骤：当stack2中不为空时，在stack2中的栈顶元素是最先进入队列的元素，可以弹出。如果stack2为空时，我们把stack1中的元素逐个弹出并压入stack2。由于先进入队列的元素被压到stack1的底端，经过弹出和压入之后就处于stack2的顶端了，又可以直接弹出。 接下来再插入一个元素d。我们还是把它压入stack1（如图1（d）所示），这样会不会有问题呢？我们考虑下一次删除队列的头部，stack2不为空，直接弹出它的栈顶元素c（如图1（e）所示）。而c的确是比d先进入队列，应该在d之前从队列中删除，因此不会出现任何矛盾。 总结完每一次在队列中插入和删除操作的过程之后，我们就可以开始动手写代码了。参考代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class QueueUsingTwoStack&lt;T&gt; &#123; //声明两个栈:stack1、stack2 private Stack&lt;T&gt; stack1; private Stack&lt;T&gt; stack2; public QueueUsingTwoStack() &#123; stack1 = new Stack&lt;T&gt;(); stack2 = new Stack&lt;T&gt;(); &#125; /** * 往队列尾部插入一个元素 * * @param element 将要插入的元素 */ public void appendTail(T element) &#123; stack1.push(element); &#125; /** * 删除队列头部元素 * * @return 队列头部元素 */ public T deleteHead() &#123; //把stack1中的元素逐个弹出并压入stack2 if (stack2.size() &lt;= 0) &#123; while (stack1.size() &gt; 0) &#123; T element = stack1.pop(); stack2.push(element); &#125; &#125; //提示队列为空，返回空值 if (stack2.size() == 0) &#123; System.out.print(\"Queue is empty.\"); return null; &#125; //删除并获得队列头部元素 T head = stack2.pop(); return head; &#125;&#125;","categories":[{"name":"编程题","slug":"编程题","permalink":"http://www.huangheng.site/categories/编程题/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.huangheng.site/tags/java/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.huangheng.site/tags/algorithm/"}]}]