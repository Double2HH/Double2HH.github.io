[{"title":"用两个队列实现栈","date":"2017-05-02T16:00:00.000Z","path":"2017/05/03/用两个队列实现栈/","text":"用两个队列实现栈。栈的声明如下，请实现它的两个函数push和pop，分别完成结点入栈和出栈的功能。 我们通过一系列栈的压入和弹出操作来分析用两个队列模拟一个栈的过程。我们先往栈内压入一个元素a。由于两个队列现在都是空的，我们可以选择把a插入两个队列中的任意一个。我们不妨把a插入queue1。接下来继续往栈内压入b、c两个元素，我们把它们都插入queue1。这个时候queue1包含3个元素a、b和c，其中a位于队列的头部，c位于队列的尾部（如图1（a）所示）。 现在我们考虑从栈内弹出一个元素。根据栈的后入先出原则，最后被压入栈的c应该最先被弹出。由于c位于queue1的尾部，而我们每次只能从队列的头部删除元素，因此我们可以先从queue1中依次删除元素a、b并插入到queue2中，再从queue1中删除元素c。这就相当于从栈中弹出元素c了（如图1（b）所示）。我们可以用同样的方法从栈内弹出元素b（如图1（c）所示）。 接下来我们考虑往栈内压入一个元素d。此时queue1已经有一个元素，我们就把d插入到queue1的尾部（如图1（d）所示）。如果我们再从栈内弹出一个元素，此时被弹出的应该是最后被压入栈的d。由于d位于queue1的尾部，我们只能先从头删除queue1的元素并插入到queue2，直到在queue1中遇到d再直接把它删除（如图1（e）所示）。 图1：用两个队列模拟一个栈的操作 参考代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class StackUsingTwoQueue&lt;T&gt; &#123; //声明两个队列:queue1、queue2 private LinkedBlockingQueue&lt;T&gt; queue1; private LinkedBlockingQueue&lt;T&gt; queue2; public StackUsingTwoQueue() &#123; queue1 = new LinkedBlockingQueue&lt;T&gt;(); queue2 = new LinkedBlockingQueue&lt;T&gt;(); &#125; /** * 将一个元素入栈 * * @param element 将要入栈的元素 */ public void push(T element) &#123; try &#123; //将元素插入到不为空的队列的尾部，如果两个队列均为空则插入到queue1 if (queue1.size() &lt;= 0 &amp;&amp; queue2.size() &lt;= 0) &#123; queue1.put(element); &#125; else if (queue1.size() &gt; 0) &#123; queue1.put(element); &#125; else &#123; queue2.put(element); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; /** * 将栈顶元素出栈 * * @return 栈顶元素 */ public T pop() &#123; T result = null; if (queue1.size() &lt;= 0 &amp;&amp; queue2.size() &lt;= 0) &#123; //栈为空 System.out.print(\"Stack is empty.\"); return null; &#125; else if (queue1.size() &gt; 0 &amp;&amp; queue2.size() &lt;= 0) &#123; //队列queue1不为空，queue2为空， //将queue1中除尾部元素之外的全部元素依次出队列并插入到queue2队列中 try &#123; while (queue1.size() &gt; 1) &#123; T element = queue1.poll(); queue2.put(element); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //queue1中仅剩的一个元素即为栈顶元素 result = queue1.poll(); &#125; else if (queue1.size() &lt;= 0 &amp;&amp; queue2.size() &gt; 0) &#123; //队列queue2不为空，queue1为空， //将queue2中除尾部元素之外的全部元素依次出队列并插入到queue1队列中 try &#123; while (queue2.size() &gt; 1) &#123; T element = queue2.poll(); queue1.put(element); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //queue2中仅剩的一个元素即为栈顶元素 result = queue2.poll(); &#125; return result; &#125;&#125;","categories":[{"name":"编程题","slug":"编程题","permalink":"http://www.huangheng.site/categories/编程题/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.huangheng.site/tags/java/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.huangheng.site/tags/algorithm/"}]},{"title":"用两个栈实现队列","date":"2017-05-01T16:00:00.000Z","path":"2017/05/02/用两个栈实现队列/","text":"用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail和deleteHead，分别完成在队列尾部插入结点和在队列头部删除结点的功能。 我们通过一个具体的例子来分析往该队列插入和删除元素的过程。首先插入一个元素a，不妨先把它插入到stack1，此时stack1中的元素有{a}，stack2为空。再插入两个元素b和c，还是插入到stack1中，此时stack1中的元素有{a,b,c}，其中c位于栈顶，而stack2仍然是空的（如图1（a）所示）。 这个时候我们试着从队列中删除一个元素。按照队列先入先出的规则，由于a比b、c先插入到队列中，最先被删除的元素应该是a。元素a存储在stack1中，但并不在栈顶上，因此不能直接进行删除。注意到stack2我们还一直没有使用过，现在是让stack2发挥作用的时候了。如果我们把stack1中的元素逐个弹出并压入stack2，元素在stack2中的顺序正好和原来在stack1中的顺序相反。因此经过3次弹出stack1和压入stack2操作之后，stack1为空，而stack2中的元素是{c,b,a}，这个时候就可以弹出stack2的栈顶a了。此时的stack1为空，而stack2的元素为{c,b}，其中b在栈顶（如图1（b）所示）。 如果我们还想继续删除队列的头部应该怎么办呢？剩下的两个元素是b和c，b比c早进入队列，因此b应该先删除。而此时b恰好又在栈顶上，因此直接弹出stack2的栈顶即可。这次弹出操作之后，stack1中仍然为空，而stack2为{c}（如图1（c）所示）。 从上面的分析中我们可以总结出删除一个元素的步骤：当stack2中不为空时，在stack2中的栈顶元素是最先进入队列的元素，可以弹出。如果stack2为空时，我们把stack1中的元素逐个弹出并压入stack2。由于先进入队列的元素被压到stack1的底端，经过弹出和压入之后就处于stack2的顶端了，又可以直接弹出。 接下来再插入一个元素d。我们还是把它压入stack1（如图1（d）所示），这样会不会有问题呢？我们考虑下一次删除队列的头部，stack2不为空，直接弹出它的栈顶元素c（如图1（e）所示）。而c的确是比d先进入队列，应该在d之前从队列中删除，因此不会出现任何矛盾。 图1:用两个栈模拟一个队列的操作 总结完每一次在队列中插入和删除操作的过程之后，我们就可以开始动手写代码了。参考代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class QueueUsingTwoStack&lt;T&gt; &#123; //声明两个栈:stack1、stack2 private Stack&lt;T&gt; stack1; private Stack&lt;T&gt; stack2; public QueueUsingTwoStack() &#123; stack1 = new Stack&lt;T&gt;(); stack2 = new Stack&lt;T&gt;(); &#125; /** * 往队列尾部插入一个元素 * * @param element 将要插入的元素 */ public void appendTail(T element) &#123; stack1.push(element); &#125; /** * 删除队列头部元素 * * @return 队列头部元素 */ public T deleteHead() &#123; //把stack1中的元素逐个弹出并压入stack2 if (stack2.size() &lt;= 0) &#123; while (stack1.size() &gt; 0) &#123; T element = stack1.pop(); stack2.push(element); &#125; &#125; //提示队列为空，返回空值 if (stack2.size() == 0) &#123; System.out.print(\"Queue is empty.\"); return null; &#125; //删除并获得队列头部元素 T head = stack2.pop(); return head; &#125;&#125;","categories":[{"name":"编程题","slug":"编程题","permalink":"http://www.huangheng.site/categories/编程题/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.huangheng.site/tags/java/"},{"name":"algorithm","slug":"algorithm","permalink":"http://www.huangheng.site/tags/algorithm/"}]}]